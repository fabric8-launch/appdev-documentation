[id="spring-reactive-introduction_{context}"]
= Introduction to Spring Reactive

The Spring reactive stack is built on link:https://projectreactor.io/[Project Reactor], a reactive library for building non-blocking applications on the JVM that implements messaging over HTTP based on the the link:https://www.reactive-streams.org/[Reactive Streams specification] and RxJava2.
Reactor provides the link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] and link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] functional API types that enable asynchronous event stream processing.

On top of the Reactor library, Spring Reactive relies on WebFlux, an asynchronous web application framework based on the Reactive Streams specifications.
While WebFlux is designed to work primarily with Spring Reactor, due to its compliance with Reactive Streams, WebFlux can also operate in other asynchronous runtime environments, such as Netty or Undertow.

Spring WebFlux and Reactor enable you to create applications that are:

* Non-blocking, meaning that the application does not remain inaccessible to further requests while waiting for a response from a remote component or service that is required to complete handling the current request.
* Asynchronous, meaning that rather than handling incoming requests in a sequence, the application responds to event from an event stream (also called an event loop) by generating its own response events and publishing them to the event stream where they can be picked up by other clients in the application and processed further.
* Event-Driven, meaning that the application operates by responding to events generated by the user or by another service (such as mouse clicks or HTTP requests).
* Scalable, meaning that increasing the number of Publishers or Subscribers to match the required event processing capacity, does not increase the complexity of routing request between as drastically as in a non-event-driven application.
This enables reactive applications to handle large numbers of events using fewer computing and networking resources as compared to other application programming models.
* Resilient, meaning that these application can handle failure of services they depend on without a significant negative impact on their quality of service.

// TODO:  these should be relocated to the Spring-Web implementation concepts
Additional advantages of using Spring WebFlux include:

Similarity with SpringMVC::
Due to the high degree of similarity between the SpringMVC API types and WebFlux API types, it is easy to re-apply knowledge of SpringMVC to programming applications with WebFLux.

Annotated controllers::
WebFlux retains the endpoint controller annotations introduced by SpringMVC (Both SpringMVC and WebFlux support reactive RxJava2 and Reactor return types).
In addition to all the annotation types inherited from Spring MVC, WebFlux also supports `@RequestBody` arguments.

//Efficient resource usage::
//Reactor and WebFlux handle high volumes of concurrent events (on the order of tens of millions of messages per second) using a smaller amount of threads compared to Servlet-based libraries handling the same workload.

Functional programming support::
Reactor interacts directly with the Java 8 Functional API, as well as `CompletablebFuture`, and `Stream` APIs.
In addition to annotation-based endpoints, WebFlux also supports functional endpoints.

//TODO: add additional resources section
//Reactive manifesto: https://www.reactivemanifesto.org/
