
When you deploy an application using {ProductShortName}, its important to know if it is available and if it can start handling incoming requests. Implementing the _health check_ pattern allows you to monitor the health of an application, which includes if an application is available and whether it is able to service requests.

In order to understand the health check pattern, you need first understand the following concepts:

Liveness::
Liveness defines whether an application is running or not. Sometimes a running application moves into an unresponsive or stopped state and needs to be restarted. Checking for liveness helps determine whether or not an application needs to be restarted.

Readiness::
Readiness defines whether a running application can service requests. Sometimes a running application moves into an error or broken state where it can no longer service requests. Checking readiness helps determine whether or not requests should continue to be routed to that application.

Fail-over::
Fail-over enables failures in servicing requests to be handled gracefully. If an application fails to service a request, that request and future requests can then _fail-over_ or be routed to another application, which is usually a redundant copy of that same application.

Resilience and Stability::
Resilience and Stability enable failures in servicing requests to be handled gracefully. If an application fails to service a request due to connection loss, in a resilient system that request can be retried after the connection is re-established.

Probe::
A probe is a Kuberbetes action that periodically performs diagnostics on a running container.


The purpose of this use case is to demonstrate the health check pattern through the use of probing. {ProductShortName} uses probing to report the liveness and readiness or an application. In this use case, you configure an application which exposes an HTTP `health` endpoint used by {ProductShortName} to issue HTTP requests. If the container is alive, according to the liveness probe on the `health` HTTP endpoint, the management platform receives `200` as return code and no further action is required. If the `health` HTTP endpoint does not return a response, for example if the JVM is no longer running or a thread is blocked, then the application is not considered alive according to the liveness probe. In that case, the platform kills the pod corresponding to that application and recreates a new pod to restart the application.

This use case also allows you to demonstrate and use a readiness probe. In cases where the application is running but is unable to handle requests, such as when the application returns a HTTP `503` response code during restart, this application is not considered ready according to the readiness probe. If the application is not considered ready by the readiness probe, {ProductShortName} will not route requests to that application until it is considered ready according to the readiness probe.

Using {ProductShortName} gives you all the advantages that come with using microservices including flexibility and choice of framework and languages. At the same time {ProductShortName} provides useful infrastructure for interoperability and running your microservices such tools for doing health checking.