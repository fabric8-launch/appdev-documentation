= Interacting with the Secured Booster

The Secured booster provides a default HTTP endpoint that accepts `GET` requests if the caller is authenticated and authorized. The client first authenticates against the {RHSSO} server and then performs a `GET` request against the Secured booster using the access token returned by the authentication step.

[[secured-endpoint]]
== The Secured Endpoint
When using a client to interact with the booster, you must specify the Secured booster endpoint, which is the Greeting service. You can get a list of the endpoints using the `oc get routes` command. The following table shows sample output from the `oc get routes` where you can obtain the Secured booster and SSO server endpoint names.


[width="100%",options="header"]
|====================================================================
|Name       |Host/Port |Path |Services |Port |Termination
a|secure-sso 
a|secure-sso-myproject.LOCAL_OPENSHIFT_HOSTNAME
a|secure-sso
a|<all>
a|passthrough

a|secured-{runtime-tag}-http
a|secured-{runtime-tag}-http-myproject.LOCAL_OPENSHIFT_HOSTNAME
a|secured-{runtime-tag}-http
a|<all>
a|

a|sso
a|sso-myproject.LOCAL_OPENSHIFT_HOSTNAME
a|sso
a|<all>
a|
|====================================================================


== On the Command Line
Requesting a token can be achieved by sending a HTTP POST request to the SSO server. In the following example the the link:https://stedolan.github.io/jq/[jq CLI tool] is used to to extract the token value from the JSON response.

=== Requesting an Access Token
There are a few things you need to request a token. The attributes are usually shared with each service and kept secret, but for demonstration purposes they are displayed here:

[source,bash,options="nowrap",subs="attributes+"]
----
REALM=master
USER=alice
PASSWORD=password
CLIENT_ID=demoapp
SECRET=1daa57a2-b60e-468b-a3ac-25bd2dc2eadc
----

Using that information, use the `curl` command to request a token:

[source,bash,options="nowrap",subs="attributes+"]
----
$ curl -sk -X POST https://<SSO_AUTH_SERVER_URL>/auth/realms/$REALM/protocol/openid-connect/token \
  -d grant_type=password \
  -d username=$USER \
  -d password=$PASSWORD \
  -d client_id=$CLIENT_ID \
  -d client_secret=$SECRET
----

NOTE: The `-sk` option tells curl to ignore failures resulting from self-signed certificates

The link:https://stedolan.github.io/jq/[`jq` utility] makes it much easier to parse any kind of JSON response payload. To access the token value with `jq`: 

[source,bash,options="nowrap",subs="attributes+"]
----
$ curl ... | jq '.access_token'

"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRek1nbXhZMUhrQnpxTnR0SnkwMm5jNTNtMGNiWDQxV1hNSTU1MFo4MGVBIn0.eyJqdGkiOiI0NDA3YTliNC04YWRhLTRlMTctODQ2ZS03YjI5MjMyN2RmYTIiLCJleHAiOjE1MDc3OTM3ODcsIm5iZiI6MCwiaWF0IjoxNTA3NzkzNzI3LCJpc3MiOiJodHRwczovL3NlY3VyZS1zc28tc3NvLWRlbW8uYXBwcy5jYWZlLWJhYmUub3JnL2F1dGgvcmVhbG1zL21hc3RlciIsImF1ZCI6ImRlbW9hcHAiLCJzdWIiOiJjMDE3NWNjYi0wODkyLTRiMzEtODI5Zi1kZGE4NzM4MTVmZTgiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJkZW1vYXBwIiwiYXV0aF90aW1lIjowLCJzZXNzaW9uX3N0YXRlIjoiMDFjOTkzNGQtNmZmOS00NWYzLWJkNWUtMTU4NDI5ZDZjNDczIiwiYWNyIjoiMSIsImNsaWVudF9zZXNzaW9uIjoiMzM3Yzk0MTYtYTdlZS00ZWUzLThjZWQtODhlODI0MGJjNTAyIiwiYWxsb3dlZC1vcmlnaW5zIjpbIioiXSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImJvb3N0ZXItYWRtaW4iXX0sInJlc291cmNlX2FjY2VzcyI6eyJzZWN1cmVkLWJvb3N0ZXItZW5kcG9pbnQiOnsicm9sZXMiOlsiYm9vc3Rlci1hZG1pbiJdfSwiYWNjb3VudCI6eyJyb2xlcyI6WyJtYW5hZ2UtYWNjb3VudCIsInZpZXctcHJvZmlsZSJdfX0sIm5hbWUiOiJBbGljZSBJbkNoYWlucyIsInByZWZlcnJlZF91c2VybmFtZSI6ImFsaWNlIiwiZ2l2ZW5fbmFtZSI6IkFsaWNlIiwiZmFtaWx5X25hbWUiOiJJbkNoYWlucyIsImVtYWlsIjoiYWxpY2VAa2V5Y2xvYWsub3JnIn0.mjmZe37enHpigJv0BGuIitOj-kfMLPNwYzNd3n0Ax4Nga7KpnfytGyuPSvR4KAG8rzkfBNN9klPYdy7pJEeYlfmnFUkM4EDrZYgn4qZAznP1Wzy1RfVRdUFi0-GqFTMPb37o5HRldZZ09QljX_j3GHnoMGXRtYW9RZN4eKkYkcz9hRwgfJoTy2CuwFqeJwZYUyXifrfA-JoTr0UmSUed-0NMksGrtJjjPggUGS-qOn6OgKcmN2vaVAQlxW32y53JqUXctfLQ6DhJzIMYTmOflIPy0sgG1mG7sovQhw1xTg0vTjdx8zQ-EJcexkj7IivRevRZsslKgqRFWs67jQAFQA"
----

=== Invoking the Secured Service Using the Token

In order to invoke the secured service, you need to use an the access, or bearer, token. The token is attached to the HTTP headers, for example: 

[source,bash,options="nowrap",subs="attributes+"]
----
$ > GET /api/greeting HTTP/1.1
> Host: <SERVICE_HOST>
> User-Agent: curl/7.51.0
> Accept: */*
> Authorization: Bearer <TOKEN>
----

To attach the token to the HTTP headers on the command line:

[source,bash,options="nowrap",subs="attributes+"]
----
$ curl -v -H "Authorization: Bearer <TOKEN>" http://<SERVICE_HOST>/api/greeting

{
    "content": "Hello, World!",
    "id": 2
}
----


=== Decoding JWT
The access tokens are link:https://jwt.io[JSON Web Token] and can be decoded using the link:https://jwt.io/#debugger-io[JWT Debugger]:

. Go to link:https://jwt.io/#debugger-io[JWT Debugger].
. Select `RS256` from the _Algorithm_ drop down menu.
+
NOTE: Make sure the web form has actually updated to display the RSASHA256(...) information in the Signature section. If it does not, try switching back to HS256 and then back to RS256.

. Paste the following content in the top text box in the _VERIFY SIGNATURE_ section.
+
[source,base64,options="nowrap",subs="attributes+"]
----
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoETnPmN55xBJjRzN/cs30OzJ9olkteLVNRjzdTxFOyRtS2ovDfzdhhO9XzUcTMbIsCOAZtSt8K+6yvBXypOSYvI75EUdypmkcK1KoptqY5KEBQ1KwhWuP7IWQ0fshUwD6jI1QWDfGxfM/h34FvEn/0tJ71xN2P8TI2YanwuDZgosdobx/PAvlGREBGuk4BgmexTOkAdnFxIUQcCkiEZ2C41uCrxiS4CEe5OX91aK9HKZV4ZJX6vnqMHmdDnsMdO+UFtxOBYZio+a1jP4W3d7J5fGeiOaXjQCOpivKnP2yU2DPdWmDMyVb67l8DRA+jh0OJFKZ5H2fNgE3II59vdsRwIDAQAB
-----END PUBLIC KEY-----
----
+
NOTE: This is the master realm public key from the Secured booster's {RHSSO} server deployment.

. Paste the `token` output from the client output in the _Encoded_ box.
. You will see `Signature Verified` on the debugger page.

== Using the Web Interface
The secured endpoint also contains a web interface to interact with it. Access it using the xref:secured-endpoint[endpoint address].

When using the web interface, you will go through the following steps to see how security is enforced, how authentication happens, and how the token is requested and attached to an authenticated invocation.

. Open the web interface and click on _Invoke_. This sends an unauthenticated request to the Greeting service.
+
image::sso-main.png[]
. The services responds with an `HTTP 401 Unauthorized` status code.
+
image::sso-unauthenticated.png[]
. Click _Login_ to authenticate yourself against {RHSSO}. This redirects you to the SSO server and requests your credentials. 
. Log in as xref:sso-users[the _Alice_ user].
. Once authenticated you are redirected to the web interface, which includes a bearer token shown in the command line output at the bottom of the page.
+
image::sso-alice.png[]
. Click _Invoke_ again to access the Greeting service.
. Confirm there is no exception and JSON response payload displayed. This means the service accepted your bearer token and you are authorized access to the Greeting service.
+
image::sso-invoke-alice.png[]
. Logout.
. Click on _Invoke_. Confirm this sends an unauthenticated request to the Greeting service. 
. Click _Login_ and log in as xref:sso-users[the _admin_ user].
+
image::sso-admin.png[]
. Click on _Invoke_. 
. Confirm the service responds with an `HTTP 403 Forbidden` status code since the _admin_ user is not authorized to access the Greeting service.
+
image::sso-unauthorized.png[]